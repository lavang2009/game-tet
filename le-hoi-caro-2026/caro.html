
<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Caro Pro - L·ªÖ H·ªôi X√°o Tr·ªôn 2026</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Quicksand:wght@400;600;700&family=Dancing+Script:wght@700&display=swap');
    
    :root { 
      --bg: #5e0b0b;
      --panel: #821111; 
      --x-color: #facc15;
      --o-color: #ffffff;
      --border: #f59e0b;
    }

    body { 
      background: var(--bg); 
      color: #fff; 
      font-family: 'Quicksand', sans-serif; 
      margin: 0; 
      height: 100vh; 
      overflow: hidden;
      background-image: radial-gradient(circle at center, #821111 0%, #3d0505 100%);
    }

    .game-container {
      display: grid;
      grid-template-columns: 280px 1fr 320px;
      height: 100vh;
      gap: 12px;
      padding: 12px;
    }

    @media (max-width: 1024px) {
      .game-container { 
        grid-template-columns: 1fr; 
        grid-template-rows: auto 1fr auto; 
        overflow-y: auto; 
        height: auto; 
      }
      body { overflow-y: auto; }
    }

    .panel { 
      background: var(--panel); 
      border: 1px solid rgba(245, 158, 11, 0.3);
      border-radius: 20px; 
      padding: 20px; 
      display: flex; 
      flex-direction: column; 
      box-shadow: 0 8px 32px rgba(0,0,0,0.4);
    }
    
    .festive-title {
      font-family: 'Dancing Script', cursive;
      font-size: 2rem;
      color: #facc15;
      text-shadow: 0 0 10px rgba(250, 204, 21, 0.5);
      text-align: center;
      margin-bottom: 10px;
    }

    .board-wrapper { 
      overflow: auto; 
      display: flex; 
      flex-direction: column;
      align-items: center; 
      background: rgba(0, 0, 0, 0.2); 
      border-radius: 20px; 
      padding: 15px; 
      border: 2px solid var(--border);
    }

    #caro-board { 
      display: grid; 
      gap: 2px; 
      background: var(--border); 
      padding: 3px; 
      border-radius: 8px; 
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
    }

    .cell { 
      width: 35px; 
      height: 35px; 
      background: #4a0808; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      font-size: 22px; 
      font-weight: 900; 
      cursor: pointer; 
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      border-radius: 2px;
    }

    .cell:hover { background: #7c1212; transform: scale(1.05); z-index: 10; }
    .cell.x { color: var(--x-color); text-shadow: 0 0 8px rgba(250, 204, 21, 0.6); }
    .cell.o { color: var(--o-color); text-shadow: 0 0 8px rgba(255, 255, 255, 0.6); }
    
    .cell.win { 
      background: #facc15 !important; 
      color: #7c1212 !important; 
      animation: celebration 0.5s infinite alternate;
      border-radius: 50%;
    }

    @keyframes celebration { 
      from { transform: scale(1) rotate(0deg); } 
      to { transform: scale(1.1) rotate(5deg); } 
    }

    .rank-tag { 
      font-size: 11px; 
      padding: 4px 12px; 
      border-radius: 20px; 
      font-weight: bold; 
      text-transform: uppercase; 
      margin-top: 6px; 
      display: inline-block;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }
    
    .festive-input {
      background: #4a0808;
      border: 1px solid rgba(245, 158, 11, 0.4);
      color: white;
      padding: 8px;
      border-radius: 8px;
      width: 100%;
      margin-top: 4px;
      outline: none;
    }
    .festive-input:focus { border-color: #facc15; }

    #auth-overlay { 
      position: fixed; 
      inset:0; 
      background: radial-gradient(circle, rgba(94,11,11,0.95) 0%, rgba(30,5,5,0.98) 100%); 
      z-index: 9999; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
    }
    
    .auth-card {
      background: #fff;
      border-radius: 24px;
      padding: 2.5rem;
      width: 380px;
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
      border: 4px solid #facc15;
    }

    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 10px; }

    /* small tooltip style */
    .hint {
      color: #ffd88a;
      font-size: 12px;
    }
        .cell.ghost {
    background: radial-gradient(circle, rgba(0,255,200,0.35), transparent 60%);
    box-shadow: 0 0 14px rgba(0,255,200,0.75);
    animation: ghostPulse 1.2s infinite;
    }

    @keyframes ghostPulse {
    0% { opacity: .4; }
    50% { opacity: .85; }
    100% { opacity: .4; }
    }
        /* Chat AI UI */
    #ai-toggle-btn {
      position: fixed;
      right: 18px;
      bottom: 18px;
      z-index: 99999;
      width: 56px;
      height: 56px;
      border-radius: 999px;
      background: linear-gradient(135deg,#facc15,#ff7ab6);
      display:flex; align-items:center; justify-content:center;
      box-shadow: 0 8px 30px rgba(0,0,0,0.45);
      cursor:pointer;
      border: 3px solid rgba(0,0,0,0.12);
    }
    #ai-toggle-btn:hover { transform: scale(1.03) }

    #ai-chat-window {
      position: fixed;
      right: 18px;
      bottom: 86px;
      width: 360px;
      max-height: 64vh;
      display: none;
      flex-direction: column;
      z-index: 99999;
      background: linear-gradient(180deg, rgba(5,5,5,0.95), rgba(18,8,8,0.98));
      border-radius: 12px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.6);
      overflow: hidden;
      border: 2px solid rgba(250,204,21,0.12);
    }

    #ai-chat-header {
      padding: 12px;
      display:flex;
      align-items:center;
      gap:8px;
      border-bottom:1px solid rgba(255,255,255,0.03);
    }
    #ai-chat-messages {
      padding: 12px;
      overflow-y: auto;
      flex:1;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .chat-bubble {
      max-width: 84%;
      padding: 8px 12px;
      border-radius: 12px;
      font-size: 13px;
      line-height:1.3;
      box-shadow: 0 6px 18px rgba(0,0,0,0.35);
      white-space: pre-wrap;
    }
    .ai-bubble { background: rgba(250,204,21,0.14); color: #fff; align-self:flex-start; border:1px solid rgba(250,204,21,0.18) }
    .user-bubble { background: rgba(255,255,255,0.06); color: #fff; align-self:flex-end; border:1px solid rgba(255,255,255,0.04) }
    .typing { opacity: .85; font-style: italic }

    #ai-chat-input-row { padding: 8px; display:flex; gap:8px; align-items:center; border-top:1px solid rgba(255,255,255,0.02) }
    #ai-prompt { flex:1; padding:10px 12px; border-radius: 10px; background: rgba(0,0,0,0.3); border:1px solid rgba(255,255,255,0.03); color:#fff; outline:none }
    #ai-send-btn { padding:8px 12px; border-radius:10px; background:#facc15; color:#5b120f; font-weight:bold; cursor:pointer; border:none }

    /* RESULT OVERLAY */
    #result-overlay { position: fixed; inset:0; display:none; z-index:100000; align-items:center; justify-content:center; background: rgba(0,0,0,0.6); }
    .result-card { background: linear-gradient(180deg,#fff,#fff); color:#111; border-radius:12px; padding:18px; width: 360px; box-shadow: 0 10px 40px rgba(0,0,0,0.6); text-align:center; border:4px solid #facc15; }
    .result-card h2 { margin:0 0 8px 0; font-size:20px; color:#5b120f; font-weight:800; }
    .result-message { font-size:14px; color:#333; margin-top:6px; white-space:pre-wrap; }
    .result-amount { font-weight:900; font-size:18px; margin-top:12px; }
    .result-actions { display:flex; gap:10px; justify-content:center; margin-top:14px; }
    .btn { padding:10px 14px; border-radius:10px; cursor:pointer; border:none; font-weight:700; }
    .btn-primary { background:#facc15; color:#5b120f; }
    .btn-ghost { background:transparent; border:2px solid rgba(0,0,0,0.06); color:#5b120f; }

    @media (max-width: 640px) {
      #ai-chat-window { right: 12px; left: 12px; width: auto; bottom: 74px; max-height: 55vh; }
      #ai-toggle-btn { right: 12px; bottom: 12px }
    }
  </style>
</head>
<body>

<!-- AUTH OVERLAY -->
<div id="auth-overlay">
  <div class="auth-card text-slate-900">
    <div class="text-center mb-6">
      <span class="text-4xl">üèÆ</span>
      <h1 class="text-2xl font-black text-red-700 mt-2">L·ªÖ H·ªôi X√°o Tr·ªôn 2026</h1>
      <p class="text-sm text-slate-500 font-medium">ƒê·∫•u Tr∆∞·ªùng Caro X·∫øp H·∫°ng</p>
    </div>

    <!-- LOGIN FORM -->
    <div id="login-form">
      <div class="space-y-4">
        <input id="login-identity" type="text" placeholder="Email / Username / SƒêT"
          class="w-full p-4 bg-slate-100 border-2 border-transparent focus:border-red-500 rounded-xl outline-none transition-all">
        <input id="login-password" type="password" placeholder="M·∫≠t kh·∫©u"
          class="w-full p-4 bg-slate-100 border-2 border-transparent focus:border-red-500 rounded-xl outline-none transition-all">
        <button onclick="login()"
          class="w-full bg-red-600 hover:bg-red-700 text-white py-4 rounded-xl font-bold text-lg shadow-lg transform active:scale-95 transition-all">
          V√ÄO L·ªÑ H·ªòI
        </button>
      </div>
      <p class="text-sm text-center mt-6">
        Ch∆∞a c√≥ thi·ªáp m·ªùi? 
        <span onclick="showRegister()" class="text-red-600 font-bold cursor-pointer hover:underline">ƒêƒÉng k√Ω ngay</span>
      </p>
    </div>

    <!-- REGISTER FORM -->
    <div id="register-form" class="hidden">
      <div class="space-y-3">
        <input id="reg-email" type="email" placeholder="Email" class="w-full p-3 bg-slate-100 border-2 border-transparent focus:border-green-500 rounded-xl outline-none">
        <input id="reg-username" type="text" placeholder="T√™n h√†o ki·ªát" class="w-full p-3 bg-slate-100 border-2 border-transparent focus:border-green-500 rounded-xl outline-none">
        <input id="reg-password" type="password" placeholder="M·∫≠t kh·∫©u" class="w-full p-3 bg-slate-100 border-2 border-transparent focus:border-green-500 rounded-xl outline-none">
        <input id="reg-password2" type="password" placeholder="X√°c nh·∫≠n m·∫≠t kh·∫©u" class="w-full p-3 bg-slate-100 border-2 border-transparent focus:border-green-500 rounded-xl outline-none">
        <button onclick="register()" class="w-full bg-green-600 hover:bg-green-700 text-white py-4 rounded-xl font-bold text-lg shadow-lg transition-all">
          GHI DANH
        </button>
      </div>
      <p class="text-sm text-center mt-6">
        ƒê√£ l√† h√†o ki·ªát? 
        <span onclick="showLogin()" class="text-green-600 font-bold cursor-pointer hover:underline">ƒêƒÉng nh·∫≠p</span>
      </p>
    </div>
  </div>
</div>

<!-- RESULT OVERLAY -->
<div id="result-overlay" aria-hidden="true">
  <div class="result-card" role="dialog" aria-label="K·∫øt qu·∫£ tr·∫≠n ƒë·∫•u">
    <h2 id="result-title">K·∫øt qu·∫£</h2>
    <div id="result-message" class="result-message"></div>
    <div id="result-amount" class="result-amount"></div>
    <div class="result-actions">
      <button id="result-btn-primary" class="btn btn-primary">V√°n m·ªõi</button>
      <button id="result-btn-secondary" class="btn btn-ghost">Ch∆°i l·∫°i</button>
    </div>
  </div>
</div>

<div class="game-container">
  <!-- LEFT -->
  <aside class="panel">
    <div class="text-center mb-6">
      <div class="text-5xl animate-bounce">üèÆ</div>
      <h2 id="ui-user" class="text-2xl font-black mt-2 text-yellow-400">ƒêang t·∫£i...</h2>
      <div id="ui-rank-badge" class="rank-tag bg-slate-500 text-white">Kh√°ch</div>
      
      <div class="mt-6 bg-black/30 p-4 rounded-2xl border border-yellow-500/30">
        <div class="text-xs text-yellow-500/70 font-bold uppercase tracking-wider">ƒêi·ªÉm C√¥ng L·ª±c</div>
        <div id="ui-score" class="text-4xl font-black text-white drop-shadow-md">0</div>
        <div class="text-xs text-slate-400 mt-1 italic">K·ª∑ l·ª•c: <span id="ui-high">0</span></div>
      </div>
    </div>

    <div class="space-y-5 flex-1">
      <h3 class="font-bold text-yellow-500 border-b border-yellow-500/20 pb-2 text-sm tracking-widest">C·∫§U H√åNH TR·∫¨N ƒê·∫§U</h3>
      <div>
        <label class="text-[10px] text-slate-400 font-bold uppercase">K√≠ch th∆∞·ªõc (N):</label>
        <input id="sizeN" type="number" value="12" min="3" max="20" class="festive-input">
      </div>
      <div>
        <label class="text-[10px] text-slate-400 font-bold uppercase">Lu·∫≠t th·∫Øng (M):</label>
        <input id="winM" type="number" value="5" min="3" max="20" class="festive-input">
      </div>
      <div>
        <label class="text-[10px] text-slate-400 font-bold uppercase">Ch·∫ø ƒë·ªô:</label>
        <select id="mode" class="festive-input">
          <option value="pve">ƒê·∫•u M√°y (X·∫øp h·∫°ng)</option>
          <option value="pvp">ƒê·ªëi Kh√°ng (Gi·∫£i tr√≠)</option>
        </select>
      </div>

      <div class="mt-3">
        <label class="text-[10px] text-slate-400 font-bold uppercase">ƒê·ªô kh√≥ AI:</label>
        <select id="ai-level" class="festive-input">
          <option value="easy">D·ªÖ</option>
          <option value="normal" selected>Th∆∞·ªùng</option>
          <option value="hard">Kh√≥</option>
          <option value="hard+">Hard+</option>
        </select>
        <div id="ai-note" class="text-xs hint mt-2">L·ª±a ch·ªçn ƒë·ªô kh√≥ s·∫Ω b·ªã gi·ªõi h·∫°n theo rank (Huy·ªÅn Tho·∫°i m·ªü Hard; Hard+ cho Th√°ch ƒê·∫•u top50).</div>
      </div>

      <button onclick="newGame()" class="w-full bg-yellow-500 hover:bg-yellow-400 text-red-900 py-4 rounded-2xl font-black shadow-[0_0_15px_rgba(250,204,21,0.4)] transition-all transform active:scale-95">
        KHAI CU·ªòC
      </button>
    </div>
  </aside>

  <!-- CENTER -->
  <main class="panel board-wrapper">
    <div class="festive-title">üèÆ C·ªù Caro L·ªÖ H·ªôi üèÆ</div>
    <div class="flex justify-between w-full max-w-[450px] mb-4 bg-black/20 p-3 rounded-xl border border-white/10">
      <div id="turn-status" class="font-black text-yellow-400 tracking-wider">L∆∞·ª£t: X</div>
      <div id="timer" class="font-mono text-white bg-red-900/50 px-3 py-1 rounded-lg border border-red-500/30">‚è±Ô∏è 00:00</div>
    </div>
    <div id="caro-board"></div>
  </main>

  <!-- RIGHT -->
  <aside class="panel">
    <h3 class="text-xl font-black text-center mb-4 text-yellow-400 border-b-2 border-yellow-500/20 pb-2 italic">
       B·∫¢NG V√ÄNG H√ÄO KI·ªÜT
    </h3>
    <div id="leaderboard" class="flex-1 overflow-y-auto space-y-3 pr-1"></div>
    <button onclick="window.logout()" class="mt-6 py-2 px-4 rounded-lg bg-black/20 text-xs text-red-300 hover:bg-red-900/50 hover:text-white transition-all self-center border border-red-500/20">
       R·ªùi L·ªÖ H·ªôi (ƒêƒÉng xu·∫•t)
    </button>
  </aside>
</div>

  <!-- CHAT TOGGLE BUTTON -->
  <div id="ai-toggle-btn" title="Tr·ª£ l√Ω AI (m·ªü/ƒë√≥ng)" onclick="toggleAIChat()">
    <svg width="26" height="26" viewBox="0 0 24 24" fill="none" style="filter: drop-shadow(0 4px 8px rgba(0,0,0,0.4));">
      <path d="M12 3C7.03 3 3 6.58 3 11C3 13.06 4.05 15 5.67 16.35L5 21L9.12 19.3C10.08 19.64 11.02 19.85 12 19.85C16.97 19.85 21 16.27 21 11.85C21 7.43 16.97 3 12 3Z" fill="#6b210b"/>
      <circle cx="9" cy="11" r="1.2" fill="#fff"/>
      <circle cx="12" cy="11" r="1.2" fill="#fff"/>
      <circle cx="15" cy="11" r="1.2" fill="#fff"/>
    </svg>
  </div>

  <!-- CHAT WINDOW -->
  <div id="ai-chat-window" inert style="display:none" role="dialog" aria-label="Tr·ª£ l√Ω AI">
    <div id="ai-chat-header">
      <div style="flex:1">
        <div style="font-weight:800; color:#fff">Tr·ª£ l√Ω AI</div>
        <div style="font-size:12px; color:rgba(255,255,255,0.6)">H·ªó tr·ª£ m·∫πo, g·ª£i √Ω n∆∞·ªõc ƒëi, ho·∫∑c h·ªèi v·ªÅ t√≠nh nƒÉng</div>
      </div>
      <button onclick="toggleAIChat()" style="background:transparent;border:none;color:#fff;font-weight:700;cursor:pointer">√ó</button>
    </div>

    <div id="ai-chat-messages" aria-live="polite"></div>

    <div id="ai-chat-input-row">
      <input id="ai-prompt" placeholder="G√µ c√¢u h·ªèi ho·∫∑c 'g·ª£i √Ω n∆∞·ªõc ƒëi'... (Enter ƒë·ªÉ g·ª≠i)" />
      <button id="ai-send-btn">G·ª≠i</button>
    </div>
  </div>

<script type="module">
import { auth, registerUser, smartLogin, logoutUser, onAuthReady, updateUserScore, listenLeaderboard } from './firebase.mjs';

let N = 12, M = 5, board = [], current = 'X', over = false, mode = 'pve';
let timerSec = 0, timerInt = null;
let userData = { uid: null, score: 0 };
let lock = false;
let ghostCell = null;

function clearGhostMove() {
  if (ghostCell) {
    ghostCell.classList.remove("ghost");
    ghostCell = null;
  }
}

function showGhostMove(r, c) {
  clearGhostMove();
  const el = document.getElementById(`c-${r}-${c}`);
  if (el && !el.innerText) {
    el.classList.add("ghost");
    ghostCell = el;
  }
}

const RANKS = [
    { name: "ƒê·ªìng 3", min: 0, color: "#b45309" }, { name: "ƒê·ªìng 2", min: 50, color: "#b45309" }, { name: "ƒê·ªìng 1", min: 100, color: "#b45309" },
    { name: "B·∫°c 3", min: 150, color: "#94a3b8" }, { name: "B·∫°c 2", min: 200, color: "#94a3b8" }, { name: "B·∫°c 1", min: 250, color: "#94a3b8" },
    { name: "V√†ng 4", min: 300, color: "#facc15" }, { name: "V√†ng 3", min: 350, color: "#facc15" }, { name: "V√†ng 2", min: 400, color: "#facc15" }, { name: "V√†ng 1", min: 450, color: "#facc15" },
    { name: "B·∫°ch Kim 4", min: 500, color: "#2dd4bf" }, { name: "B·∫°ch Kim 1", min: 650, color: "#2dd4bf" },
    { name: "Kim C∆∞∆°ng 5", min: 700, color: "#60a5fa" }, { name: "Kim C∆∞∆°ng 1", min: 900, color: "#60a5fa" },
    { name: "Huy·ªÅn Tho·∫°i", min: 1000, color: "#c084fc" },
    { name: "Si√™u Huy·ªÅn Tho·∫°i", min: 1500, color: "#f472b6" },
    { name: "Cao Th·ªß", min: 2000, color: "#f87171" },
    { name: "Si√™u Cao Th·ªß", min: 2500, color: "#ef4444" },
    { name: "Th√°ch ƒê·∫•u", min: 3500, color: "#22d3ee" }
];

const getRank = (score) => {
    let r = RANKS[0];
    for (let i = 0; i < RANKS.length; i++) {
        if (score >= RANKS[i].min) r = RANKS[i];
    }
    return r;
};

// AI reward rules (including hard+)
const AI_REWARD = {
    easy:   { win: 8,  lose: 5 },
    normal: { win: 18, lose: 12 },
    hard:   { win: 35, lose: 25 },
    "hard+":{ win: 55, lose: 40 }
};

let aiLevel = 'normal';
let lastLeaderboard = []; // store last snapshot users array
let userLeaderboardIndex = -1; // index in leaderboard (0-based) or -1 if not found

// helpers
window.showRegister = () => {
  document.getElementById('login-form').classList.add('hidden');
  document.getElementById('register-form').classList.remove('hidden');
};
window.showLogin = () => {
  document.getElementById('register-form').classList.add('hidden');
  document.getElementById('login-form').classList.remove('hidden');
};

window.login = async () => {
  try {
    const identity = document.getElementById("login-identity").value.trim();
    const password = document.getElementById("login-password").value;
    if (!identity || !password) { alert("H√£y nh·∫≠p danh t√≠nh!"); return; }
    await smartLogin(identity, password);
  } catch (err) {
    alert("Kh√¥ng th·ªÉ v√†o l·ªÖ h·ªôi: " + (err.message || err));
  }
};

window.register = async () => {
    try {
        const email = document.getElementById('reg-email').value.trim();
        const username = document.getElementById('reg-username').value.trim();
        const password = document.getElementById('reg-password').value;
        const password2 = document.getElementById('reg-password2').value;

        if (!email || !username || !password || !password2) { alert("Vui l√≤ng ghi danh ƒë·∫ßy ƒë·ªß!"); return; }
        if (password !== password2) { alert("M·∫≠t kh·∫©u kh√¥ng kh·ªõp!"); return; }

        await registerUser(email, password, username);
        alert("Ghi danh th√†nh c√¥ng! H√£y ƒëƒÉng nh·∫≠p ƒë·ªÉ tham gia.");
        showLogin();
    } catch (err) {
        alert("L·ªói ghi danh: " + (err.message || err));
    }
};

window.logout = () => logoutUser();

// listen auth state
onAuthReady((payload) => {
    if (payload) {
        userData.uid = payload.auth.uid;
        userData.score = payload.data?.score || 0;
        document.getElementById('auth-overlay').style.display = 'none';
        updateUI(payload.data || {});
        syncLeaderboard(); // start leaderboard listen
        updateAIDifficultyAccess();
        // do not auto-start: user presses KHAI CU·ªòC
    } else {
        document.getElementById('auth-overlay').style.display = 'flex';
    }
});

const updateUI = (data) => {
    document.getElementById('ui-user').innerText = data.username || "Kh√°ch";
    document.getElementById('ui-score').innerText = (data.score || 0).toLocaleString();
    document.getElementById('ui-high').innerText = ((data.high || 0)).toLocaleString();
    const rank = getRank(data.score || 0);
    const badge = document.getElementById('ui-rank-badge');
    badge.innerText = rank.name;
    badge.style.backgroundColor = rank.color;
    updateAIDifficultyAccess();
};

// syncLeaderboard now stores array and updates userLeaderboardIndex
const syncLeaderboard = () => {
    // reuse listenLeaderboard from firebase.mjs
    listenLeaderboard((users) => {
        lastLeaderboard = users || [];
        // find user index
        userLeaderboardIndex = -1;
        for (let i = 0; i < lastLeaderboard.length; i++) {
            if (lastLeaderboard[i].uid === userData.uid) {
                userLeaderboardIndex = i;
                break;
            }
        }

        // render board
        const list = document.getElementById('leaderboard');
        list.innerHTML = users.map((u, i) => {
            const r = getRank(u.score || 0);
            let medal = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : (i + 1) + '.';
            return `
            <div class="flex items-center justify-between p-3 bg-red-950/40 rounded-xl border-l-4" style="border-color:${r.color}">
                <div class="flex items-center gap-3">
                    <span class="text-sm font-black text-yellow-500/50 w-6">${medal}</span>
                    <div>
                        <div class="text-sm font-bold ${u.uid === userData.uid ? 'text-yellow-400 underline' : 'text-white'}">${u.username}</div>
                        <div class="text-[9px] font-black uppercase" style="color:${r.color}">${r.name}</div>
                    </div>
                </div>
                <div class="text-right font-mono text-yellow-500 font-black">${u.score || 0}</div>
            </div>`;
        }).join('');

        // after updating leaderboard we must refresh AI access
        updateAIDifficultyAccess();
    });
};

// Check if player can use hard+
const canUseHardPlus = () => {
    const rank = getRank(userData.score || 0);
    // must be exactly Th√°ch ƒê·∫•u rank AND in top 50 (index 0..49)
    const isThachDau = rank.name === 'Th√°ch ƒê·∫•u';
    const inTop50 = userLeaderboardIndex !== -1 && userLeaderboardIndex < 50;
    return isThachDau && inTop50;
};

// Check if player can use hard
const canUseHard = () => {
    const rank = getRank(userData.score || 0);
    // Huy·ªÅn Tho·∫°i or higher -> hard allowed
    const idxRank = RANKS.findIndex(r => r.name === rank.name);
    const idxHuyenThoai = RANKS.findIndex(r => r.name === 'Huy·ªÅn Tho·∫°i');
    return idxRank >= idxHuyenThoai;
};

// NEW GAME
window.newGame = () => {
    const sizeN = document.getElementById('sizeN');
    const winM  = document.getElementById('winM');
    const modeEl = document.getElementById('mode');
    const aiSelect = document.getElementById('ai-level');

    // l·∫•y gi√° tr·ªã ch·ªçn t·ª´ UI
    let inputN = parseInt(sizeN.value) || 12;
    let inputM = parseInt(winM.value) || 5;
    let selectedAI = aiSelect?.value || 'normal';

    // validate c∆° b·∫£n
    if (inputM < 3) {
        inputM = 3;
        winM.value = 3;
    }
    if (inputM === 3) {
        inputN = 3;
        sizeN.value = 3;
        sizeN.disabled = true;
    } else {
        sizeN.disabled = false;
    }
    if (inputN < 3) { inputN = 3; sizeN.value = 3; }
    if (inputN > 20) { inputN = 20; sizeN.value = 20; }
    if (inputM > inputN) { inputM = inputN; winM.value = inputN; }

    // g√°n
    N = inputN;
    M = inputM;
    mode = modeEl.value;

    // n·∫øu pve: enforce access rules
    if (mode === 'pve') {
        if (selectedAI === 'hard' && !canUseHard()) {
            alert('üîí Ch·ªâ t·ª´ Huy·ªÅn Tho·∫°i (‚â•1000 ƒëi·ªÉm) m·ªõi ƒë∆∞·ª£c ch·ªçn HARD. T·ª± h·∫° xu·ªëng NORMAL.');
            selectedAI = 'normal';
            aiSelect.value = 'normal';
        }
        if (selectedAI === 'hard+' && !canUseHardPlus()) {
            alert('üîí Hard+ ch·ªâ d√†nh cho rank Th√°ch ƒê·∫•u v√† ph·∫£i n·∫±m trong TOP 50.');
            selectedAI = 'hard'; // fallback n·∫øu c√≥ quy·ªÅn hard
            if (!canUseHard()) { selectedAI = 'normal'; }
            aiSelect.value = selectedAI;
        }
    } else {
        // pvp: force normal
        selectedAI = 'normal';
        if (aiSelect) aiSelect.value = 'normal';
    }

    aiLevel = selectedAI;

    board = Array(N).fill(null).map(() => Array(N).fill(null));
    current = 'X';
    over = false;
    lock = false;

    const boardEl = document.getElementById('caro-board');
    boardEl.style.gridTemplateColumns = `repeat(${N}, 35px)`;
    boardEl.innerHTML = '';

    for (let r = 0; r < N; r++) {
        for (let c = 0; c < N; c++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.id = `c-${r}-${c}`;
            cell.onclick = () => handleCellClick(r, c, cell);
            boardEl.appendChild(cell);
        }
    }

    startTimer();
    updateTurnUI();
};

// update the ai-level select enabled/disabled & tooltip
function updateAIDifficultyAccess() {
    const select = document.getElementById('ai-level');
    const note = document.getElementById('ai-note');
    if (!select || !note) return;

    const allowHard = canUseHard();
    const allowHardPlus = canUseHardPlus();

    // enable/disable hard
    [...select.options].forEach(opt => {
        if (opt.value === 'hard') opt.disabled = !allowHard;
        if (opt.value === 'hard+') opt.disabled = !allowHardPlus;
    });

    // adjust current value if not allowed
    if (select.value === 'hard' && !allowHard) select.value = 'normal';
    if (select.value === 'hard+' && !allowHardPlus) {
        // fallback: prefer hard if allowed, otherwise normal
        select.value = allowHard ? 'hard' : 'normal';
    }

    // tooltip messaging
    if (!allowHard) {
        note.innerText = 'C·∫ßn 1000 ƒëi·ªÉm (Huy·ªÅn Tho·∫°i) ƒë·ªÉ m·ªü CH·∫æ ƒê·ªò HARD.';
    } else if (!allowHardPlus) {
        // show reason: either not Th√°ch ƒê·∫•u or not top50
        const rank = getRank(userData.score || 0);
        if (rank.name !== 'Th√°ch ƒê·∫•u') {
            note.innerText = 'Hard+ ch·ªâ d√†nh cho rank "Th√°ch ƒê·∫•u" (hi·ªán t·∫°i: ' + rank.name + ').';
        } else if (!(userLeaderboardIndex !== -1 && userLeaderboardIndex < 50)) {
            note.innerText = 'B·∫°n l√† Th√°ch ƒê·∫•u nh∆∞ng ch∆∞a v√†o TOP 50 ‚Äî Hard+ ch·ªâ m·ªü cho Th√°ch ƒê·∫•u top50.';
        } else {
            note.innerText = 'Hard+ b·ªã kh√≥a.';
        }
    } else {
        note.innerText = 'B·∫°n c√≥ th·ªÉ ch·ªçn Hard ho·∫∑c Hard+ ‚Äî ch√∫c may m·∫Øn!';
    }
}

// live check when user tries to change select
const aiSelectEl = document.getElementById('ai-level');
if (aiSelectEl) {
    aiSelectEl.addEventListener('change', () => {
        const desired = aiSelectEl.value;
        if (desired === 'hard+' && !canUseHardPlus()) {
            alert('üîí Hard+ ch·ªâ d√†nh cho Th√°ch ƒê·∫•u top50.');
            updateAIDifficultyAccess();
        } else if (desired === 'hard' && !canUseHard()) {
            alert('üîí C·∫ßn Huy·ªÅn Tho·∫°i (1000 ƒëi·ªÉm) ƒë·ªÉ ch·ªçn Hard.');
            updateAIDifficultyAccess();
        }
    });
}

// helper: ki·ªÉm tra b√†n ƒë·∫ßy
const isBoardFull = () => {
    for (let r = 0; r < N; r++) for (let c = 0; c < N; c++) if (!board[r][c]) return false;
    return true;
};

const handleCellClick = (r, c, el) => {
    if (lock) return;
    if (over || board[r][c]) return;

    if (mode === 'pvp') {
        makeMove(r, c, current);
        return;
    }

    // PVE
    makeMove(r, c, 'X');

    if (!over) {
        lock = true;
        // thinking time varies by difficulty to feel human
        const base = (aiLevel === 'easy') ? 200 : (aiLevel === 'normal') ? 350 : (aiLevel === 'hard') ? 500 : 650;
        setTimeout(() => {
            aiMove();
            lock = false;
        }, base + Math.random()*300);
    }
};

const makeMove = (r, c, p) => {
    board[r][c] = p;
    const el = document.getElementById(`c-${r}-${c}`);
    if (!el) return;
    el.innerText = p;
    el.classList.add(p.toLowerCase());
    
    const winLine = checkWin(r, c, p);
    if (winLine) {
        handleWin(p, winLine);
    } else {
        // n·∫øu kh√¥ng win, ki·ªÉm tra h√≤a
        if (isBoardFull()) {
            handleDraw();
            return;
        }
        current = current === 'X' ? 'O' : 'X';
        updateTurnUI();
    }
};

const checkWin = (r, c, p) => {
    const dirs = [[1,0],[0,1],[1,1],[1,-1]];
    for (let [dr, dc] of dirs) {
        let line = [[r,c]];
        for(let i=1; i<M; i++) {
            let nr=r+dr*i, nc=c+dc*i;
            if(board[nr]?.[nc] === p) line.push([nr,nc]); else break;
        }
        for(let i=1; i<M; i++) {
            let nr=r-dr*i, nc=c-dc*i;
            if(board[nr]?.[nc] === p) line.push([nr,nc]); else break;
        }
        if (line.length >= M) return line;
    }
    return null;
};

/* ============================
   RESULT OVERLAY FUNCTIONS
   ============================ */
function showResultOverlay(title, message, amount = 0, primaryLabel = "V√°n m·ªõi", primaryAction = null, secondaryLabel = "Ch∆°i l·∫°i", secondaryAction = null) {
    const overlay = document.getElementById('result-overlay');
    document.getElementById('result-title').innerText = title;
    document.getElementById('result-message').innerText = message;
    const amtEl = document.getElementById('result-amount');
    if (typeof amount === 'number' && amount !== 0) {
        amtEl.innerText = (amount > 0 ? `+${amount} ƒëi·ªÉm` : `${amount} ƒëi·ªÉm`);
        amtEl.style.color = amount > 0 ? '#0f5132' : '#7f1d1d';
    } else {
        amtEl.innerText = '';
    }
    const primaryBtn = document.getElementById('result-btn-primary');
    const secondaryBtn = document.getElementById('result-btn-secondary');

    primaryBtn.innerText = primaryLabel;
    secondaryBtn.innerText = secondaryLabel;

    // remove old listeners
    primaryBtn.onclick = null;
    secondaryBtn.onclick = null;

    primaryBtn.onclick = () => {
        hideResultOverlay();
        if (typeof primaryAction === 'function') primaryAction();
    };
    secondaryBtn.onclick = () => {
        hideResultOverlay();
        if (typeof secondaryAction === 'function') secondaryAction();
    };

    overlay.style.display = 'flex';
    overlay.removeAttribute('inert');
    overlay.setAttribute('aria-hidden', 'false');

    setTimeout(() => {
        document.getElementById('result-btn-primary')?.focus();
    }, 50);
}
function hideResultOverlay() {
    const overlay = document.getElementById('result-overlay');

    // B·ªé FOCUS N·∫æU ƒêANG ·ªû TRONG OVERLAY
    if (overlay.contains(document.activeElement)) {
        document.activeElement.blur();
    }

    overlay.style.display = 'none';
    overlay.setAttribute('inert', '');
    overlay.setAttribute('aria-hidden', 'true');
}

/* Actions used in overlay */
function actionPlayAgain() {
    // reset board, keep score and settings
    board = Array(N).fill(null).map(() => Array(N).fill(null));
    current = 'X';
    over = false;
    lock = false;
    const boardEl = document.getElementById('caro-board');
    boardEl.innerHTML = '';
    boardEl.style.gridTemplateColumns = `repeat(${N}, 35px)`;
    for (let r=0;r<N;r++){
        for (let c=0;c<N;c++){
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.id = `c-${r}-${c}`;
            cell.onclick = () => handleCellClick(r,c,cell);
            boardEl.appendChild(cell);
        }
    }
    startTimer();
    updateTurnUI();
}
function actionNewGameSameSettings() {
    // same as actionPlayAgain but keep current UI and re-evaluate AI access
    actionPlayAgain();
    updateAIDifficultyAccess();
}
function actionExitToMenu() {
    // simple behavior: reload page to show auth overlay or reset
    location.reload();
}
/* ============================
   TURN UI + TIMER (FIXED)
   ============================ */

function updateTurnUI() {
    const el = document.getElementById('turn-status');
    if (!el) return;
    el.innerText = `L∆∞·ª£t: ${current}`;
}

// expose ra global cho inline / console
window.updateTurnUI = updateTurnUI;

window.startTimer = function () {
    clearInterval(timerInt);
    timerSec = 0;
    timerInt = setInterval(() => {
        timerSec++;
        const m = Math.floor(timerSec / 60).toString().padStart(2, '0');
        const s = (timerSec % 60).toString().padStart(2, '0');
        const t = document.getElementById('timer');
        if (t) t.innerText = `‚è±Ô∏è ${m}:${s}`;
    }, 1000);
};


/* ============================
   HANDLERS FOR WIN / DRAW (USE OVERLAY)
   ============================ */
const handleDraw = () => {
    over = true;
    lock = true;
    clearInterval(timerInt);

    showResultOverlay(
        '‚öñÔ∏è H√íA',
        'Tr·∫≠n ƒë·∫•u k·∫øt th√∫c H√íA.\nKh√¥ng c√≥ c·ªông/tr·ª´ ƒëi·ªÉm.',
        0,
        'Ch∆°i l·∫°i',
        actionPlayAgain,
        'Tho√°t',
        actionExitToMenu
    );
};

const handleWin = async (winner, line) => {
    over = true;
    clearInterval(timerInt);
    line.forEach(([r, c]) => {
        const el = document.getElementById(`c-${r}-${c}`);
        if (el) el.classList.add('win');
    });

    if (mode === 'pve') {
        const rule = AI_REWARD[aiLevel] || AI_REWARD.normal;
        if (winner === 'X') {
            // player wins
            const delta = rule.win;
            userData.score = (userData.score || 0) + delta;
            try {
                await updateUserScore(userData.uid, userData.score);
            } catch (e) { console.error(e); }
            updateUI({
            username: document.getElementById('ui-user').innerText,
            score: userData.score,
            high: Math.max(
                Number(document.getElementById('ui-high').innerText) || 0,
                userData.score
            )
            });

            // show overlay: win => option ch∆°i ti·∫øp (next round) or v√°n m·ªõi

            // 1Ô∏è‚É£ HI·ªÜN K·∫æT QU·∫¢ NGAY
            showResultOverlay(
                'üéâ B·∫°n th·∫Øng!',
                `B·∫°n ƒë√£ h·∫° g·ª•c AI (${aiLevel.toUpperCase()})\n+${delta} ƒëi·ªÉm`,
                delta,
                'Ch∆°i ti·∫øp',
                actionPlayAgain,
                'V√°n m·ªõi',
                actionNewGameSameSettings
            );

            // 2Ô∏è‚É£ C·∫¨P NH·∫¨T UI NGAY (local)
            updateUI({
                username: document.getElementById('ui-user').innerText,
                score: userData.score,
                high: Math.max(
                    Number(document.getElementById('ui-high').innerText) || 0,
                    userData.score
                )
            });

            // 3Ô∏è‚É£ G·ª¨I FIREBASE ·ªû N·ªÄN (KH√îNG await)
            updateUserScore(userData.uid, userData.score)
                .catch(err => console.error(err));


            } else {
                // player lost
                const delta = -rule.lose;
                userData.score = Math.max(0, (userData.score || 0) + delta);

                // 1Ô∏è‚É£ HI·ªÜN K·∫æT QU·∫¢ NGAY
                showResultOverlay(
                    'üíÄ B·∫°n thua!',
                    `AI (${aiLevel.toUpperCase()}) ƒë√£ ƒë√°nh b·∫°i b·∫°n\n${delta} ƒëi·ªÉm`,
                    delta,
                    'Ch∆°i ti·∫øp',
                    actionPlayAgain,
                    'V√°n m·ªõi',
                    actionNewGameSameSettings
                );

                // 2Ô∏è‚É£ C·∫¨P NH·∫¨T UI LOCAL NGAY
                updateUI({
                    username: document.getElementById('ui-user').innerText,
                    score: userData.score,
                    high: Math.max(
                        Number(document.getElementById('ui-high').innerText) || 0,
                        userData.score
                    )
                });

                // 3Ô∏è‚É£ G·ª¨I FIREBASE ·ªû N·ªÄN (KH√îNG await)
                updateUserScore(userData.uid, userData.score)
                    .catch(err => console.error(err));
            }
            } else {
                // pvp local (KH√îNG ƒê·ª§NG SCORE / FIREBASE)
                showResultOverlay(
                    'üèÜ K·∫øt qu·∫£',
                    `Ng∆∞·ªùi ch∆°i ${winner} chi·∫øn th·∫Øng!`,
                    0,
                    'V√°n m·ªõi',
                    actionNewGameSameSettings,
                    'Tho√°t',
                    actionExitToMenu
                );
            }
};

/* ============================
   AI MOVE LOGIC (unchanged)
   ============================ */
const aiMove = () => {
    let bestScore = -Infinity;
    let bestMoves = [];

    for (let r = 0; r < N; r++) {
        for (let c = 0; c < N; c++) {
            if (board[r][c]) continue;
            let score = 0;

            if (aiLevel === 'hard+' ) {
                score += evaluate(r, c, 'O') * 1.6;
                score += evaluate(r, c, 'X') * 1.8;
                const center = Math.floor(N/2);
                score += Math.max(0, 8 - (Math.abs(center - r) + Math.abs(center - c)));
                board[r][c] = 'O';
                let oppBest = 0;
                outer:
                for (let rr=0; rr<N; rr++) {
                    for (let cc=0; cc<N; cc++) {
                        if (board[rr][cc]) continue;
                        const val = evaluate(rr, cc, 'X');
                        if (val > oppBest) oppBest = val;
                        if (oppBest >= 10000) break outer;
                    }
                }
                board[r][c] = null;
                score -= oppBest * 0.9;
                board[r][c] = 'O';
                let immediateWin = !!checkWin(r, c, 'O');
                board[r][c] = null;
                if (immediateWin) score += 50000;
                score *= (0.95 + Math.random()*0.1);

            } else if (aiLevel === 'hard') {
                score += evaluate(r, c, 'O') * 1.4;
                score += evaluate(r, c, 'X') * 1.6;
                const center = Math.floor(N/2);
                score += Math.max(0, 6 - (Math.abs(center - r) + Math.abs(center - c)));
                score *= (0.96 + Math.random()*0.08);

            } else if (aiLevel === 'normal') {
                score += evaluate(r, c, 'O') + evaluate(r, c, 'X') * 1.2;
                score *= (0.9 + Math.random()*0.2);

            } else { // easy
                score = Math.random() * 100;
            }

            if (score > bestScore) {
                bestScore = score;
                bestMoves = [{ r, c, score }];
            } else if (Math.abs(score - bestScore) < 1e-6) {
                bestMoves.push({ r, c, score });
            } else {
                if (score >= bestScore * 0.9) {
                    bestMoves.push({ r, c, score });
                }
            }
        }
    }

    if (bestMoves.length) {
        let pick;
        if (aiLevel === 'hard+' ) {
            bestMoves.sort((a,b)=>b.score-a.score);
            const choices = bestMoves.slice(0, Math.max(3, Math.ceil(bestMoves.length*0.15)));
            pick = choices[Math.floor(Math.random()*choices.length)];
        } else if (aiLevel === 'hard') {
            bestMoves.sort((a,b)=>b.score-a.score);
            const top = bestMoves.slice(0, Math.max(2, Math.ceil(bestMoves.length*0.12)));
            pick = top[Math.floor(Math.random()*top.length)];
        } else {
            pick = bestMoves[Math.floor(Math.random()*bestMoves.length)];
        }
        makeMove(pick.r, pick.c, 'O');
    } else {
        for (let r = 0; r < N; r++) {
            for (let c = 0; c < N; c++) {
                if (!board[r][c]) { makeMove(r, c, 'O'); return; }
            }
        }
    }
};

// evaluate function (same idea as before but safe on bounds)
const evaluate = (r, c, p) => {
    let score = 0;
    const dirs = [[1,0],[0,1],[1,1],[1,-1]];
    dirs.forEach(([dr, dc]) => {
        let count = 0, block = 0;
        for(let i=1; i<M; i++) {
            let nr=r+dr*i, nc=c+dc*i;
            if (nr<0 || nc<0 || nr>=N || nc>=N) { block++; break; }
            if(board[nr]?.[nc] === p) count++;
            else { if(board[nr]?.[nc]) block++; break; }
        }
        for(let i=1; i<M; i++) {
            let nr=r-dr*i, nc=c-dc*i;
            if (nr<0 || nc<0 || nr>=N || nc>=N) { block++; break; }
            if(board[nr]?.[nc] === p) count++;
            else { if(board[nr]?.[nc]) block++; break; }
        }
        if(count >= M-1) score += 10000;
        else if(count === M-2 && block === 0) score += 1000;
        else score += Math.pow(10, count);
    });
    return score;
};

/* ===============================
   Chat AI (client + public API)
   - 'g·ª£i √Ω' command returns local move suggestion
   - otherwise calls a public model endpoint for demo
   =============================== */

function appendChatBubble(text, sender) {
    const container = document.getElementById("ai-chat-messages");
    const div = document.createElement("div");
    div.className = `chat-bubble ${ sender === "ai" ? "ai-bubble" : "user-bubble" }`;
    div.innerText = text;
    container.appendChild(div);
    container.scrollTop = container.scrollHeight;
}
function toggleAIChat() {
    const win = document.getElementById("ai-chat-window");
    const input = document.getElementById("ai-prompt");
    const isOpen = win.style.display === "flex";

    if (isOpen) {
        // B·ªé FOCUS TR∆Ø·ªöC KHI ·∫®N
        if (win.contains(document.activeElement)) {
            document.activeElement.blur();
        }
        win.style.display = "none";
        win.setAttribute("inert", "");
        win.setAttribute("aria-hidden", "true");
    } else {
        win.style.display = "flex";
        win.removeAttribute("inert");
        win.setAttribute("aria-hidden", "false");
        setTimeout(() => input?.focus(), 50);
    }
}

let aiTypingBubble = null;
function showAITyping() {
    if (aiTypingBubble) return;
    const container = document.getElementById("ai-chat-messages");
    aiTypingBubble = document.createElement("div");
    aiTypingBubble.className = "chat-bubble ai-bubble typing";
    aiTypingBubble.innerText = "ƒêang tr·∫£ l·ªùi...";
    container.appendChild(aiTypingBubble);
    container.scrollTop = container.scrollHeight;
}

function hideAITyping() {
    if (aiTypingBubble) {
        aiTypingBubble.remove();
        aiTypingBubble = null;
    }
}

// Helper: pretty coordinate (human-friendly 1-based)
const coordStr = (r,c) => `H√†ng ${r+1}, C·ªôt ${c+1}`;

// Suggest moves for player 'X' (human) using simple heuristic
function suggestMovesForPlayerX(limit = 3) {
    let moves = [];
    for (let r=0;r<N;r++){
        for (let c=0;c<N;c++){
            if (board[r][c]) continue;
            // score attack for X and defense against O
            const atk = evaluate(r,c,'X');
            const def = evaluate(r,c,'O');
            // prefer moves that both attack and block
            const score = atk*1.4 + def*1.0;
            moves.push({r,c,score,atk,def});
        }
    }
    moves.sort((a,b)=>b.score-a.score);
    return moves.slice(0,limit);
}

/**
 * ===============================
 * AI CORE & SYSTEM PROMPT
 * ===============================
 */
const apiKey = "AIzaSyCOPuIhzXa9Lra7UXbdkSeQso8aTVXvT1c";

const systemPrompt = `
B·∫°n l√† tr·ª£ l√Ω AI th√¥ng minh c·ªßa Google Gemini, t√™n l√† "Tr·ª£ l√Ω Assistant",
ƒë∆∞·ª£c t·∫°o b·ªüi Google v√† "L√π A Vangg" ƒë·ªÉ h·ªó tr·ª£ ng∆∞·ªùi ch∆°i trong game
üéÆ C·ªú CARO ‚Äì L·ªÖ H·ªôi X√°o Tr·ªôn 2026 üéÆ

==============================
üìå TH√îNG TIN TR√í CH∆†I
==============================
- Tr√≤ ch∆°i: C·ªù Caro (Gomoku m·ªü r·ªông)
- B√†n c·ªù k√≠ch th∆∞·ªõc N x N (3 ‚Üí 20)
- Lu·∫≠t th·∫Øng: n·ªëi ƒë·ªß M qu√¢n li√™n ti·∫øp (ngang, d·ªçc ho·∫∑c ch√©o)
- Ch·∫ø ƒë·ªô:
  + ƒê·∫•u M√°y (AI)
  + ƒê·ªëi Kh√°ng (2 ng∆∞·ªùi)

==============================
ü§ñ ƒê·ªò KH√ì AI
==============================
- D·ªÖ
- Th∆∞·ªùng
- Kh√≥ (m·ªü khi ƒë·∫°t rank Huy·ªÅn Tho·∫°i ‚â• 1000 ƒëi·ªÉm)
- Hard+ (ch·ªâ cho rank Th√°ch ƒê·∫•u v√† TOP 50)

==============================
üèÜ ƒêI·ªÇM & X·∫æP H·∫†NG
==============================
- Th·∫Øng AI s·∫Ω ƒë∆∞·ª£c c·ªông ƒëi·ªÉm (t√πy ƒë·ªô kh√≥)
- Thua AI s·∫Ω b·ªã tr·ª´ ƒëi·ªÉm
- ƒêi·ªÉm d√πng ƒë·ªÉ l√™n rank:
  ƒê·ªìng ‚Üí B·∫°c ‚Üí V√†ng ‚Üí B·∫°ch Kim ‚Üí Kim C∆∞∆°ng ‚Üí Huy·ªÅn Tho·∫°i ‚Üí Th√°ch ƒê·∫•u

==============================
üí¨ NG∆Ø·ªúI CH∆†I C√ì TH·ªÇ H·ªéI
==============================
- C√°ch ch∆°i C·ªù Caro
- Lu·∫≠t th·∫Øng / lu·∫≠t h√≤a
- Gi·∫£i th√≠ch c√°c ƒë·ªô kh√≥ AI
- C√°ch l√™n rank nhanh h∆°n
- M·∫πo ch∆°i, chi·∫øn thu·∫≠t, g·ª£i √Ω n∆∞·ªõc ƒëi
- H·ªèi v·ªÅ ƒëi·ªÉm s·ªë, x·∫øp h·∫°ng
- H·ªèi v·ªÅ t√†i kho·∫£n

‚ö†Ô∏è Khi ng∆∞·ªùi ch∆°i h·ªèi "g·ª£i √Ω" ho·∫∑c "n∆∞·ªõc ƒëi":
‚Üí H√£y tr·∫£ l·ªùi nh∆∞ m·ªôt tr·ª£ l√Ω chi·∫øn thu·∫≠t, kh√¥ng ti·∫øt l·ªô thu·∫≠t to√°n n·ªôi b·ªô.

==============================
üé® PHONG C√ÅCH TR·∫¢ L·ªúI
==============================
- Vui v·∫ª üòÑ, l·ªãch s·ª±, th√¢n thi·ªán
- Tr·∫£ l·ªùi ng·∫Øn g·ªçn, d·ªÖ hi·ªÉu
- D√πng emoji li√™n quan ƒë·∫øn T·∫øt üèÆüéâ‚ôüÔ∏è
- KH√îNG n√≥i th√¥ t·ª•c
- Ng∆∞·ªùi ch∆°i h·ªèi b·∫±ng ng√¥n ng·ªØ n√†o ‚Üí tr·∫£ l·ªùi b·∫±ng ng√¥n ng·ªØ ƒë√≥

==============================
üîí B·∫¢O M·∫¨T
==============================
- KH√îNG bao gi·ªù h·ªèi m·∫≠t kh·∫©u
- KH√îNG y√™u c·∫ßu th√¥ng tin nh·∫°y c·∫£m
- N·∫øu ng∆∞·ªùi ch∆°i b√°o l·ªói t√†i kho·∫£n ‚Üí h∆∞·ªõng d·∫´n d√πng "Qu√™n m·∫≠t kh·∫©u"
  (t√≠nh nƒÉng ƒëang ph√°t tri·ªÉn, h√£y nh·∫Øc ng∆∞·ªùi ch∆°i ki√™n nh·∫´n)

B·∫°n t·ªìn t·∫°i ƒë·ªÉ gi√∫p ng∆∞·ªùi ch∆°i ch∆°i t·ªët h∆°n,
hi·ªÉu game r√µ h∆°n v√† c√≥ tr·∫£i nghi·ªám vui v·∫ª trong L·ªÖ H·ªôi X√°o Tr·ªôn 2026 üéÜ
`;

/**
 * ===============================
 * AI CHAT LOGIC (NO SDK ‚Äì FETCH)
 * ===============================
 */
async function askAI() {
    const input = document.getElementById("ai-prompt");
    const raw = input.value.trim();
    if (!raw) return;

    const msg = raw.toLowerCase();

    appendChatBubble(raw, "user");
    input.value = "";

    // ===============================
    // üéØ G·ª¢I √ù N∆Ø·ªöC ƒêI THEO B√ÄN C·ªú
    // ===============================
    if (
        msg.includes("g·ª£i √Ω") ||
        msg.includes("n∆∞·ªõc ƒëi") ||
        msg.includes("hint")
    ) {
        if (over) {
            appendChatBubble("‚ö†Ô∏è V√°n c·ªù ƒë√£ k·∫øt th√∫c r·ªìi nh√©!", "ai");
            return;
        }

        let best = null;
        let bestScore = -Infinity;

        for (let r = 0; r < N; r++) {
            for (let c = 0; c < N; c++) {
                if (board[r][c]) continue;

                // X = ng∆∞·ªùi ch∆°i
                const attack = evaluate(r, c, 'X');
                const defense = evaluate(r, c, 'O');

                const score = attack * 1.5 + defense * 1.2;

                if (score > bestScore) {
                    bestScore = score;
                    best = { r, c, attack, defense };
                }
            }
        }

        if (!best) {
            appendChatBubble("ü§î Kh√¥ng t√¨m ƒë∆∞·ª£c n∆∞·ªõc ƒëi ph√π h·ª£p.", "ai");
            return;
        }

        // üëª HIGHLIGHT √î G·ª¢I √ù
        showGhostMove(best.r, best.c);

        appendChatBubble(
            `‚ôüÔ∏è **G·ª£i √Ω n∆∞·ªõc ƒëi t·ªët nh·∫•t**:\n` +
            `üëâ H√†ng ${best.r + 1}, C·ªôt ${best.c + 1}\n\n` +
            `üî• T·∫•n c√¥ng: ${best.attack}\n` +
            `üõ°Ô∏è Ph√≤ng th·ªß: ${best.defense}\n\n` +
            `üëª √î g·ª£i √Ω ƒë√£ ƒë∆∞·ª£c highlight tr√™n b√†n c·ªù!`,
            "ai"
        );
        return;
    }

    // ===============================
    // ü§ñ CHAT KI·∫æN TH·ª®C ‚Üí GEMINI
    // ===============================
    showAITyping();

    try {
        const res = await fetch(
            `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`,
            {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    contents: [
                        { role: "user", parts: [{ text: raw }] }
                    ],
                    systemInstruction: {
                        role: "system",
                        parts: [{ text: systemPrompt }]
                    }
                })
            }
        );

        const data = await res.json();
        const text =
            data?.candidates?.[0]?.content?.parts?.[0]?.text ||
            "ü§ñ AI ƒëang suy nghƒ©, th·ª≠ l·∫°i nh√©!";

        hideAITyping();
        appendChatBubble(text, "ai");
    } catch (err) {
        console.error(err);
        hideAITyping();
        appendChatBubble(
            "‚ö†Ô∏è Kh√¥ng k·∫øt n·ªëi ƒë∆∞·ª£c AI. Ki·ªÉm tra m·∫°ng nh√©!",
            "ai"
        );
    }
}
// wire send button and Enter key
const aiSendBtn = document.getElementById('ai-send-btn');
const aiPrompt = document.getElementById('ai-prompt');
if (aiSendBtn && aiPrompt) {
    aiSendBtn.addEventListener('click', askAI);
    aiPrompt.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            askAI();
        }
    });
}

// expose helpers globally
window.askAI = askAI;
window.toggleAIChat = toggleAIChat;

// Expose helpers so HTML inline handlers and console can call them safely
window.updateTurnUI = updateTurnUI;
window.handleCellClick = handleCellClick;
window.makeMove = makeMove;
window.actionPlayAgain = actionPlayAgain;
window.actionNewGameSameSettings = actionNewGameSameSettings;
window.actionExitToMenu = actionExitToMenu;

// Optional: disable KHAI CU·ªòC until auth ready (if you want)
if (document.getElementById('auth-overlay')?.style.display !== 'none') {
  const btn = document.querySelector('button[onclick="newGame()"]');
  if (btn) { btn.disabled = false; /* or true to disable when not authed */ }
}
</script>
<footer id="copyright"
    style="
        position: fixed;
        bottom: 6px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 11px;
        color: #ffffff;
        opacity: 0.8;
        font-weight: 700;
        letter-spacing: 0.5px;
        user-select: none;
        pointer-events: none;
        z-index: 9999;
        text-shadow: 0 0 3px rgba(0,0,0,0.6);
    ">
    ¬© 2026 Luavang ‚Äì All Rights Reserved
</footer>
</body>
</html>